Welcome to "At Home Modifier" hack of xf86-input-evdev. The original
README is moved to README.orig.

Search for the word "News" for the news.

Contents
========
* What it is
* Web site
* Get it
* Usage
* Author
* Bugs, Wish list
* Random bits
* History
* Source code
* Copyright

What it is
==========
It enables for example "shift/space dual role key." When you press the
space key alone, it's a space; but when you press it with another key,
it's a shift. Any pairs of keys are possible. It is a fork of evdev
driver = xf86-input-evdev.

With this hack, your hands can stay at the home position almost
always, and feel more "at home", thus "At Home Modifier".

More precisely, you specify pairs of two keycodes, the "original", and
the "translated". The last event gets recorded in this patch.  After
the press of one of "original" keys, the driver instead reports a
translated key press event. When an original key is released, it sends
a release of the translated key. And it sends a press and release of
the original key if necessary, judging from the last event.

Web site
========
http://gitorious.org/at-home-modifier/pages/Home

Forum / mailing list is found at:
http://at-home-modifier.2300353.n4.nabble.com/

Distro forum threads:
* Gentoo: http://forums.gentoo.org/viewtopic-t-865313.html
* Arch: https://bbs.archlinux.org/viewtopic.php?pid=938140
* Ubuntu: http://ubuntuforums.org/showthread.php?p=10907505
* Debian: http://forums.debian.net/viewtopic.php?f=20&t=65950

Get it
======

Download
--------
The tar.gz is here:
http://gitorious.org/at-home-modifier/download/blobs/raw/master/source/ahm-2.6.3.tar.gz

You can also download the patch against the Xorg's original
xf86-input-evdev from the website.

git
---
Git access is available, too. For the first time, install git, and clone as
  $ cd some/dir
  $ git clone git://gitorious.org/at-home-modifier/at-home-modifier.git

You can receive updates by
  $ cd some/dir/at-home-modifier
  $ git pull

Version tags
------------
  $ git tag -l "ahm*"
lists all releases, like ahm-2.5.1.

You can see the difference to the original code by:
  $ git diff xf86-input-evdev-2.5.0..ahm-2.5.0

Install
-------
See also the distro forum threads listed above.

* Gentoo Linux users can use ebuild files. Get one from the web site.
* Arch Linux AUR repository entry is:
  https://aur.archlinux.org/packages.php?ID=49546

Other Linux users can install it by replacing xf86-input-evdev.
I'd appreciate it a lot if you could send me your distro support.

Compilation can be done just the same way as the original.

Usage
=====
First, know the keycodes you need, which are numbers assigned to each
physical key. It's easiest to install and invoke "xev" commands. In my
case it says space is 65, and left shift is 50. OK. Then write your
xorg.conf or xorg.conf.d/10-keyboard.conf:

  # For the detail see "man xorg.conf" or your distro doc.
  Section "InputClass"
    Identifier "my keyboard"
    Driver "evdev"
    Option "XKBOptions" "terminate:ctrl_alt_bksp" # and so on

    # If you save this file under xorg.conf.d/ :
    Option "AutoServerLayout" "on"

    MatchIsKeyboard "on"
    # If you have multiple keyboards, you want something like one of them:
    #  MatchProduct "AT Translated Set 2 keyboard"
    #  MatchUSBID "0566:3029"
    # Name is found in Xorg log, following the message "Adding input device"
    # or by
    # $ cat /proc/bus/input/devices

    ### at-home-modifier options begin here.
    # The basic option.
    Option "TransMod" "65:50 102:241" # Defines key/modifier pairs.

    ## Fine tuning options. Explained in a later section.
    # For the first time, omit them.
    # Option "AhmTimeout" "400" # In millisecond.
    # Option "AhmDelay" "65 102" # Delayed keys.
    # Option "AhmFreezeTT" "true"
    # Option "AhmResetTime" "10" # In sec.
    # Option "AhmPaddingInterval" "10" # In millisecond.
  EndSection

Note: disable autorepeat for the shift (or any modifier) key, as
  $ xset -r 50

If you want to specify multiple pairs, separate them with whitespaces,
like this:

  Option "TransMod" "65:240 102:241 100:241"

Don't forget to restart X!

Options recognized by at-home-modifier (in fact, by any X drivers)
are printed to X log, typically /var/log/Xorg.0.log, like this:

  [    50.579] (**) Option "AhmTimeout" "400"

Fine tuning options
-------------------
For the first time, skip this section. Come back after you actually
try.

*** Other keys ***

The bottom row of my keyboard is Esc-BS-Spc-Ret-Tab, from left to
right, with the overlay Alt-Shift-Ctrl-Shift-Alt. (Japanese keyboards
have many keys you can press with thumbs.) For that radical change,
you need "xmodmap" command, or for more complicated changes, tamper
with files in /usr/share/X11/xkb/symbols

You can use any keys for transmods. "d" & "k" (and so on) may be good.
When you want to capitalize the left-hand keys, press "k", and "d"
for right-hands. This may sound too complex, but you'll be soon
accustomed.

*** Fast type fix (delay) ***

Users of this hack often have "tongue-twister of finger": Suppose you
want " x". If the first press of space/shift is followed first by a
press of x and then a release of space/shift, you'll get an upper-case X
instead.
 
To fix it, you can let "delay" be associated to space/shift, like:

    Option "AhmDelay" "65 102" # Delayed keys. Separate by white space

Then the press of x (or any) following space/shift is "delayed",
and completes after release of space/shift or x.

There's a trade off. Whenever you want a real shift, you have to
release the space/shift later.

Notice that *original* keycodes are used in the X configuration file,
so in this example, 65 = space, not 50 = left shift.

*** Cancellation by long press (timeout) ***

Suppose you were about to input shift + A and pressed space/shift, but
you changed your mind. If you release the space/shift key, you'll
receive one space, but it's not what you want!

Actually, a workaround is provided by time-out. A long enough press
cancels that kind of press. If you have the following line in evdev
driver configuration,

  Option "AhmTimeout" "400" # In millisecond.

then a single press and release of space/shift key produces nothing if
the press lasts more than 0.4 sec. The default is 0.6 sec. You can disable
timeout by setting it to 0.

This feature was suggested by a user known as "bloom" in the Arch
Linux forum. Thanks.

*** Successive transmod tuning ***

A subtle fix is enabled by default; suppose a transmod X has been
pressed. If "transmod Y press, X release" follows, then the press of Y
is treated as the original key. It's probably what you want.

You can disable it by setting the boolean option "AhmFreezeTT" to false.
("TT" is meant for "transmod-transmod".)

See also "Corner cases in press and release order" below.

*** Reset ***

Sometimes transmods get frozen, so the workaround is provided; just
leave the keyboard long enough time (default 10 secs) untouched.

You can change this time with the following option:
    Option "AhmResetTime" "10" # In sec.
To disable this feature, set it to 0.

Reset is implemented by sending release events to all translated
modifiers, and clearing internal variables. The time measurement is
not exact, and the maximal error is 1 sec. (It's because the
sub-second field of timeval struct is ignored.) The exact time the
rest is done is the first time you touch the keyboard.

*** Gtk widget double-press workaround (padding interval) ***

Suppose you focus a gtk window with a button widget. When you press
the shift/space, the button should be pressed. But with this hack,
you may have to press the key twice; the first press merely focuses
the button, and the second key press becomes the real push.

As a workaround, "padding interval" can be set:
    Option "AhmPaddingInterval" "10" # In millisecond.
The default value is 10 ms, and I think it's good, but if it doesn't
work, set it bigger.

How it works: remember that a press and release of shift/space key
sends a press of shift, its release, a press of space, and its
release. Padding interval is inserted between the shift release and
the space press. Bigger the value, likelier to work, but the latency
gets bigger, too.

I don't know what's happening in gtk, but this solves.

More on keycodes
----------------
It's good to know that you can also tell keycodes by looking at
/usr/share/X11/xkb/keycodes/evdev in order to customize the keyboard
layout with XKB. For example that file says:

    <SPCE> = 65;  // space
    ...
    <LFSH> = 50;  // left shift

Ok, but what's this?
    <AE02> = 11;

Hm, if you use for example Italian layout, see
/usr/share/X11/xkb/symbols/it. It has lines:

  xkb_symbols "basic" {
   ...
   key <AE02>  { [         2,   quotedbl,  twosuperior, dead_doubleacute ] };
   ...
  }

  xkb_symbols "nodeadkeys" {
    // Modifies the basic italian layout to eliminate all dead keys
    ...
    key <AE02>  { [         2,   quotedbl,  twosuperior,  doubleacute ] };
    ...
  }

Aha, so that key is basically "2".

Please!
-------
If you think this fork is good, please tell it to others, at blog,
forum, etc. If it doesn't become popular, it remains my personal hack,
and it may soon become impossible for me to maintain!

Please give your feedback. The host site doesn't provide an access
counter, so I can't measure the popularity.

Author
======
Teika kazura <teika ahm-is-great at lavabit ahm-is-great dot com>

Delete "ahm-is-great" in the address.

It's good *not* to trust authors you find on the Web. You may be
reassured to know that I was a developer of Sawfish window manager:
  http://sawfish.wikia.com/wiki/User:Teika_kazura

Maintainer wanted
-----------------
Please, take me over.

Bugs, Wish list
===============

Fixed bugs
----------
* In 2.6.0
  ** Double shift bug
  Suppose both key a and b are translated to shift. Press a, b, and
  release b.  Then it should be 'B', but it used to emit lower b. It's
  because the release of shift was sent before b key press.

* In 2.6.2
  ** Key release interference bug
  Suppose you press x, space/shift, release x, release
  space/shift. Probably you wanted "x ". But formerly, only "x" is
  sent. (More precisely, "x" + shift are sent. Don't confuse it with
  "AhmDelay".)

  ** Frozen key bug
  Probably ahm-2.6.0 has introduced a new bug which makes some keys
  irresponsive.  The bug existed in theory, but the author has never
  experienced it actually.

  ** Memory leak
  Previous version had slight memory leaks (almost unnoticeable).

  ** (obsolete) keycode limit
  __This feature is deleted in 2.6.3__
  X's keycode limit is 255, but linux input driver's keycode limit is
  0x2ff. Now it accepts input codes > 255.

* In 2.6.3
  ** Gtk widget double press issue.
  To push a gtk button, sometimes you had to press space/shift key
  twice, but this is fixed. If it doesn't work out-of-box, set
  "AhmPaddingInterval" option.
  (This "bug" is not the author's fault, but what's bad for users
  are bugs.=)

  ** Reset and Delayed key
  "Delay" and "Reset" are features introduced in 2.6.2. If a delayed
  key is pressed after a long enough period is passed (i.e. a reset is
  done), the press was ignored. It's fixed now.

Known bugs
---------
* Switching VT: When you switch back to X from virtual console with
  (Ctrl +) Alt + Fxx, ctrl get frozen. This is mitigated with "reset"
  feature.

Not a bug
---------
Many keyboards fail to send some combinations of key presses. For
example, mine doesn't report Left-alt + space + cursor-down and
alt + space + delete (whereas alt + space + up is dispatched!!)
All normal symbol keys pressed with alt + space work.

Keyboards with "n-key rollover" are the solution, and completely ok
for this hack, but they may be expensive. (USB connection can't report
7 or more simultaneous presses, but it doesn't matter for us.)

*** Limitations ***
Each device is unaware of others. If you press space/shift and the
left click, it works as shift + click, but a space key event is
generated after it too, unless the shift is timed out.

This is a mere hack. The correct way will be to implement this in
"XKB2", which is not yet put into Xorg. If you want this to be
merged in Xorg, please help X input driver developers.

Wishes
------
"Dynamic configuration", or config changes on-the-fly may be good,
for example enabling some keys only when you're using an input method.
I don't know anything about socket or inter-process communication,
so please tell me how to do it.

Autorepeat support. For example, you press space/shift twice in a row,
and hold it long enough, then it's turned to the press of space, rather
than shift.

Bug reporting
-------------
When you report a bug, don't forget to disable autorepeat by
  $ xset -r

It's better to make AhmResetTime big, and if you enable AhmDelay,
set it big, too.

I compile with -Wall -Wextra, and my code does not bring in any extra
warning.

Corner cases in press and release order
---------------------------------------
There're many corner cases, and I can't predict all. The option
"AhmFreezeTT" is easy not only to reason, but also to code, but
more complicated examples may not be so.

More may be possible, by knowing which keys are modifiers. (This hack
doesn't use any information which are modifiers. What's done is a
simple translation.) You can get the required information by Xlib or
XKB, but it'll be an inverted implementation, fetching the high-level
part from the raw world. The correct way would be to re-implement all
in XKB2. (See above for XKB2.)

Or programmable configuration (together with timestamp support),
something like an automaton, may help.  But don't ask me it. I don't
know how to design such logic nor to write a parser.

Random bits
===========

Will this patch speed up typing?
--------------------------------
In my case, it didn't. But I (or my hands) feel far better and I can't
do without this fork any more. It's much less tiring, so it may be
more efficient if you use keyboard for long time in a day.

In fact, this hack introduces some nicety. Options like delay and
timeout are intended for the cure, but they bring in others.

Warning: Health issue
---------------------
This hack is likely to reduce the use of your pinkies, and the risk of
their injury like RSI. However, overuse of keyboards can damage *any*
digits and other parts of your hand, although pinkies are most
vulnerable.

Good keyboards
--------------
If you can buy a Japanese keyboard, I recommend one. The Japanese
keyboard is a "cheap Kinesis"; the space key is short, and there're
keys around the space key which can be easily pressed with thumbs.
(Have you ever heard of Kinesis Contoured Keyboard?) See for example
http://en.wikipedia.org/wiki/Keyboard_layout

But it's only the layout. I can't assure the overall quality. Of course
it's better to try before you buy...

"Realforce" keyboard made by Topre is unique with capacitive key
switch whose touch is really soft. "HHK Professional" (HHK = Happy
Hacking Keyboard) also uses Topre's switch.

See also "not a bug" section above. Kinesis contoured, Realforce and
HHK Professional come with n-key rollover.

FYI: mine is OWL-KB86STD made by Owltech. It's cheap, and has cheap
touch, but I like the layout.

Alternatives
============
There're some alternative candidates of at-home-modifier.

* actkbd: It works by direct access to /dev/input, but not updated
  since 2007. I don't think it's flexible enough.

    http://users.softlab.ntua.gr/~thkala/projects/actkbd/

* 窓使いの憂鬱 (Mado-tsukai no yū-utsu; meaning "Spleen of Windows
  Users") for Linux & Darwin: It's a port of a Windows key tuner
  software "窓使いの憂鬱", comparable to AutoHotkey. Japanese
  documentation only. The author is not reachable. Not maintained
  actively. It uses uinput.

    http://www42.tok2.com/home/negidakude/

History
=======

News
----
* 2.6.3 (nov 2011):
  * Bugs fixed
    Gtk button double press bug. Reset and delayed key bug.
  * Big keycode support is deleted.
    In 2.6.2, big keycode support was introduced, but it's
    deleted. loadkeys (1) command suffices.
* 2.6.2 (oct 2011):
  * New features
    Long press cancellation (Option "AhmTimeout"), fast type fix
    (Option "AhmDelay"), successive transmod tuning (Option
    "AhmFreezeTT"), reset (Option "AhmResetTime") are implemented.
  * Bugs fixed
    Release interference bug, keycode limit bug, and 2 other minor
    bugs are fixed.
  * Documentation
    New sections: "Not a bug", "Corner cases", "Alternatives", "Source
    code".
    New bug item: "Switching VT".
    New wish items: "Dynamic configuration", "autorepeat support"
  * Feature deleted in later release.
    "Big keycode support" is introduced in 2.6.2, but deleted in 2.6.3.
* 2.6.1 was never released.
* 2.6.0 (apr 2011): Merged upstream 2.6.0. "Double shift bug" is fixed.
* 2.5.1 (feb 2011): Minor documentation updates.
* 2.5.0 (feb 2011): Initial release. Forked from upstream 2.5.0 = xf86-input-evdev-2.5.0.

Versions 2.X.y are based on the upstream 2.X.0, unless noted explicitly.

Background
----------
What was proposed originally was called "SandS" - stands for "Space and
Shift" - which dates back to year 2001, by K. Kimura.[1] There's
implementations in Mac and Win, and has a modest popularity in Japan
still in year 2011.

In 2008 T. Matsuyama implemented it for X keyboard driver.[2] Then
came a port to evdev driver by "jeneshicc".[3] But they lack
generality; you can only use physical shift, alt, and space keys. My
code is based on the last patch.

[1] (Japanese) http://hp.vector.co.jp/authors/VA002116/
[2] (Japanese)
http://dev.ariel-networks.com/Members/matsuyama/keyboard-customize
[3] (Japanese):
http://d.hatena.ne.jp/jeneshicc/20100306/1267843799

Source code
===========

Required knowledge
------------------
Required is only C knowledge, none of X. I've added some comments, so
it must be easy to understand.

src/evdev.h
-----------
Search for "ahm variables".

In src/evdev.c, gcc __attribute__ is used. To support other compilers,
it's defined to null when __GNUC__ is not defined.

src/evdev.c
-----------
* Parsing options
  Ahm options are parsed in function NewEvdevPreInit. Search for
  "parse ahm options".

* Earlier event handling
  In the Xorg original code, keyboard events are handled by
  EvdevQueueKbdEvent. Ahm wraps it with AhmStep1 and AhmStep2, and
  WrapEvdevQueueKbdEvent.

* Later event handling
  In the original code, events get really sent in
  EvdevPostQueuedEvents. To implement AhmPaddingInterval, this
  function is changed a bit, by queuing key events in ahm's own queue,
  and asynchronous timer is set. Timer related functions I've added
  are: AhmWakeupHandler, AhmBlockHandler, AhmRegisterTimers and
  AhmFinalise.

License
=======
Distributed under MIT License; Same as Xorg.
